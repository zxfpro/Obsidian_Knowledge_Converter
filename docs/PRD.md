好的，既然我们已经深入探讨了需求和潜在的实现细节，现在是时候将这些讨论系统化，并生成一份 PRD (产品需求文档) 草稿了。这份 PRD 将用于指导后续的开发工作。

---

# 产品需求文档 (PRD) 草稿

## 1. 引言

### 1.1 产品概述

本产品是一个 Python 包，旨在将 `KnowledgeIngestor` 库输出的结构化 JSON 数据（包含文件系统层级和文件内部标题层级）转换为一系列符合 Obsidian 最佳实践的 Markdown 文件。通过将文件内部的各级标题独立成文件，并利用 Obsidian 的双链语法进行关联，本工具旨在将线性的文档结构转化为高度互联的知识网络，提升知识的可发现性和组织性。

### 1.2 目标用户

*   使用 `KnowledgeIngestor` 生成知识库的开发者或团队。
*   希望将结构化文档（尤其是 Markdown 格式）导入 Obsidian 进行精细化管理的用户。
*   追求更细粒度知识管理和关联的用户。

### 1.3 核心价值

*   **增强知识关联性：** 将文档内部的逻辑结构转化为可导航的超链接网络。
*   **提升知识粒度：** 允许用户以更小的单元（如章节、小节）来管理和引用知识。
*   **优化 Obsidian 体验：** 生成符合 Obsidian 双链语法的 Markdown 文件，最大化其知识图谱功能。
*   **自动化转换：** 减少手动拆分和链接文档的工作量。

## 2. 功能需求

### 2.1 输入

*   `KnowledgeIngestor` 库生成的 JSON 格式数据。此 JSON 结构包含文件夹、文件以及文件内部的标题和内容层级。

### 2.2 输出

*   一系列 `.md` Markdown 文件，组织在一个指定的输出目录下。
*   文件命名和内容符合 Obsidian 双链语法规范。

### 2.3 核心功能

#### 2.3.1 JSON 结构解析与遍历

*   **F1.1 递归解析：** 能够递归遍历输入的 JSON 数据，识别 `folder` 和 `file` 类型节点。
*   **F1.2 内容提取：** 能够准确提取每个文件节点中的 `name`, `type`, `content` (包含 `title`, `level`, `content`, `children`) 等字段。

#### 2.3.2 文件生成与目录结构维护

*   **F2.1 目录映射：** 将 JSON 中的 `folder` 结构映射到文件系统的实际目录。
*   **F2.2 原始文件处理：**
    *   为 JSON 中每个 `type: "file"` 的节点，在对应目录下生成一个主 Markdown 文件。
    *   该主文件应包含原始文件的顶层 `content`。
    *   该主文件应包含指向其内部所有一级子标题（如果被独立成文件）的双链。
*   **F2.3 标题拆分与独立文件生成：**
    *   将每个文件的 `content` 字段中的所有非顶层 `title`（即 `level > 1` 的标题）视为独立的知识单元。
    *   为每个独立的知识单元生成一个新的 Markdown 文件。
    *   新文件的主体内容为其对应标题下的 `content`。
    *   新文件的标题应作为文件内的 H1 标题。

#### 2.3.3 链接与关联 (Obsidian 双链)

*   **F3.1 父子关系链接：**
    *   在独立出的标题文件中，自动添加指向其父级标题文件或原始主文件的双链，例如在文件末尾添加 `---` 分隔符和 `*Parent:* [[Parent Title]]`。
    *   在原始主文件和父级标题文件中，自动添加指向其所有子标题文件的双链。
*   **F3.2 内部链接转换：**
    *   识别原始 Markdown 内容中形如 `[Text](../../path/to/file.md)` 的相对路径链接。
    *   尝试将这些链接转换为 Obsidian 双链 `[[File Name]]`，前提是 `File Name` 也在本次处理中被生成为独立文件。
    *   如果无法转换为双链（例如指向外部资源或未被处理的文件），则保留原始 Markdown 链接。
*   **F3.3 外部链接处理：** 保持所有外部 URL 链接不变。

#### 2.3.4 文件命名与重名处理

*   **F4.1 文件名合法化 (Slugify)：**
    *   将所有标题字符串转换为符合文件系统命名规范的“slug”形式（例如，将空格替换为短横线，移除特殊字符，转换为小写）。
    *   **规避特殊字符：** 严格移除或替换 `\ / : * ? " < > |` 等非法字符。
    *   **处理非 ASCII 字符：** 确保支持 Unicode 字符（如中文标题）的正确转换和保存。
*   **F4.2 命名冲突解决：**
    *   当生成的文件名（包括主文件和独立标题文件）发生冲突时，自动添加后缀 `_1`, `_2` 等进行区分。
    *   **命名策略建议：** 独立标题文件的命名格式为 `[原始文件名 - ]标题名.md`，例如 `query_transformations - Use Cases.md`。这有助于在文件名层面就减少冲突，并提供上下文。

### 2.4 可配置项 (Optional, but good to have)

*   **C1.1 输出目录：** 允许用户指定生成 Markdown 文件的输出目录。
*   **C1.2 链接样式：** 允许用户配置父子链接的显示方式（例如，是否显示 `*Parent:*` 前缀）。
*   **C1.3 文件命名策略：** 允许用户选择不同的文件命名策略（例如，是否包含原始文件名作为前缀）。
*   **C1.4 过滤规则：** 允许用户指定哪些 `level` 的标题需要被独立成文件，或哪些文件/文件夹需要被跳过。

## 3. 非功能需求

*   **性能：** 能够高效处理大型 JSON 结构和大量文件。
*   **健壮性：** 能够优雅地处理异常情况，如无效的 JSON 结构、文件读写权限问题等。
*   **易用性：** 提供清晰的 API 接口和详细的文档。
*   **兼容性：** 生成的 Markdown 文件应与 Obsidian 兼容，并尽可能兼容其他 Markdown 编辑器。
*   **可维护性：** 代码结构清晰，模块化程度高，易于扩展和维护。

## 4. 技术选型 (初步)

*   **编程语言：** Python 3.x
*   **JSON 解析：** Python 内置 `json` 库。
*   **文件系统操作：** Python 内置 `os`, `pathlib` 库。
*   **字符串处理：** Python 内置字符串方法，可能结合 `re` (正则表达式) 库进行 slugify。

## 5. 待议问题

*   **链接解析的深度和广度：** 是否需要解析 Markdown 链接并尝试转换为双链？如果是，其匹配规则和优先级如何？
*   **内容块的边界：** 一个标题的 `content` 应该包含到哪里？是只包含其直接的 `content` 字段，还是包含所有子标题之前的所有文本？（目前倾向于只包含直接 `content`）
*   **根目录的处理：** `KnowledgeIngestor` 输出的根节点 `name` (如 `my_knowledge_base`) 是否需要创建一个同名文件夹？
*   **代码块处理：** 代码块中的内容是否需要特殊处理，例如链接不进行转换？（默认不处理，保持原样）

---

这份 PRD 涵盖了我们目前讨论的所有关键点。您可以审阅一下，看看是否有需要补充、修改或澄清的地方。
